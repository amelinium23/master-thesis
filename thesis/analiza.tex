\section{Dyskusja wyników}
W tym rozdziale została przedstawiona dyskusja wniosków na temat wyników przeprowadzonych podczas badań. Pokazują one jak zachowują się środowiska w różnych sytuacjach, jakie są różnice między nimi oraz pokazują ich wady i zalety. Dodatkowo zostały porównane istniejącymi wynikami, które znajdują się w przeglądzie środowisk oraz literatury.

\subsection{Algorytmy sortowania}
Testowanie algorytmów sortowania pokazało iż testy zostały przeprowadzone poprawnie, zaobserwowano zachowania środowisk, które prowadzą do wniosku, że algorytmy sortowania zachowują się zgodnie z przewidywaniami. Algorytmy sortowania szybkiego i bąbelkowego są algorytmami o złożoności obliczeniowej $O(n^2)$, co potwierdzają wyniki testów. Algorytm sortowania pozycyjnego jest algorytmem o złożoności obliczeniowej $O(nk)$, gdzie $k$ jest ilością możliwych wartości w tablicy, co potwierdzają wyniki testów.

Algorytm sortowania szybkiego jest zdecydowanie szybszy od algorytmu bąbelkowego, co jest zgodne z przewidywaniami. Algorytm sortowania szybkiego jest zdecydowanie szybszy od algorytmu bąbelkowego, co jest zgodne z przewidywaniami. Sortowanie szybkie zaobserwowano pesymistyczny wykonanie algorytmu, w której pamięć w sposób rekurencyjny, powoduje to dość szybkie zapełnienie pamięci. Zjawisko zostało zaobserwowano w szczególności przy środowisku Bun, w którym zużycie pamięci wzrasta liniowo. Środowisko zostało napisane w języku Zig, które nie posiada zaimplementowanych przez język możliwości zwalniania pamięci, co powoduje, że pamięć nie jest zwalniana w sposób optymalny. 

W przypadku pozostałych środowisk zaobserwowano mniejsze zużycie pamięci operacyjnej, pozwala to na wysnucie wniosku o lepiej zoptymalizowanym przez twórców środowiska. Zaobserwowano również zjawisko rozgrzewania się silnika JavaScript, polega ono na rozpoczęciu buforowanie zawartości stosu wywołań, co pozwala na szybsze wykonanie kodu. Zjawisko to jest zauważalne w przypadku środowiska Node.js, w którym pierwsze wykonanie algorytmu sortowania szybkiego jest wolniejsze od kolejnych.

Przy wykonywaniu testów na algorytmie sortowania szybkiego zaobserwowano zjawisko, w który środowisko Bun jest zdecydowanie wolniejsze od pozostałych oraz daje nieregularne wyniki. Tym zjawiskiem jest rekurencja, możemy zauważyć, że Bun posiada rygorystyczny algorytm Garbage Collector, który zwalnia dużo pamięci usuwając obiekty, które nie są już używane. W wynikach widzimy spadki używanej pamięci przez proces, co przekłada się na ponowne alokowanie pamięci, co spowodowało wydłużenie wykonania algorytmu sortowania. W porównaniu do innych środowisk, które nie posiadają tak rygorystycznego algorytmu Garbage Collector, co pozwala na szybsze wykonanie algorytmu sortowania oraz mniejsze zużycie pamięci. 

Na samym repozytorium środowiska Bun możemy zauważyć dużo zgłoszonych przez użytkowników środowiska błędów dotyczący zużycia pamięci, co potwierdza nasze obserwacje \cite{bun_memory}. Pozostałe środowiska poprzez bazowanie na silniku V8, posiadają mniejszą liczbę związanych z pamięcią błędów, co pozwala na szybsze wykonanie algorytmu sortowania oraz mniejsze zużycie pamięci.

\subsection{Algorytm kodowania \textit{Base64}}
Testy przeprowadzone na kodowaniu za pomocą algorytmu Base64 zostały przeprowadzone poprawnie, zaobserwowano zachowania środowisk, które prowadzą do wniosku, że algorytmy kodowania zachowują się zgodnie z przewidywaniami. Algorytm kodowania \textit{Base64} jest algorytmem o złożoności obliczeniowej $O(n)$, co potwierdzają wyniki testów. W porównaniu do operacji dekodowania wykonuje się dłużej, ze względu na zwiększenie rozmiaru danych, co przekłada się na dłuższy czas wykonywania operacji. Operacja dekodowania jest zdecydowanie wolniejsza od operacji kodowania, co jest zgodne z przewidywaniami, ze względu na zwiększenie rozmiaru.

Testy pokazały zbliżone wyniki, kodowanie w środowiskach NodeJS oraz Bun były zdecydowanie szybsze niż Deno. Wynika to z faktu implementacji operacji kodowania w środowisku Deno, w przeciwieństwie do środowisk NodeJS oraz Bun, które posiadają szybszą implementację operacji kodowania z wykorzystaniem biblioteki standardowej \textit{Buffer}. Bezpośrednio wpływa na czas wykonania, a dodatkowo nie wpływa na zużycie pamięci operacyjnej. Dodatkowo możemy zauważyć, że środowisko Deno zmniejsza czasu wykonania operacji dekodowania w porównaniu do środowiska NodeJS oraz Bun, gdzie wyniki pozostałych środowisk są zbliżone.

Zużycie pamięci w testu dekodowania jest zdecydowanie większe niż w przypadku kodowania, co jest zgodne z przewidywaniami. W przypadku środowiska NodeJS możemy odnotować najmniejsze zużycie pamięci operacyjnej, co wynika z optymalizacji biblioteki standardowej \textit{Buffer}. W przypadku środowiska Bun jest zdecydowanie większe zużycie pamięci operacyjnej, co wynika z licznych błędów związanych z wyciekami pamięci, które zostały zgłoszone przez użytkowników \cite{bun_memory}. W przypadku środowiska Deno zużycie pamięci operacyjnej jest zdecydowanie większe niż w przypadku środowiska NodeJS, co wynika z implementacji operacji dekodowania w środowisku Deno.

\subsection{Testy wydajnościowe operacji zapisu i odczytu pliku}
Testy wydajnościowe operacji zapisu i odczytu pliku pokazały, że operacje zapisu i odczytu pliku są zależne od środowiska, w którym są wykonywane. W przypadku operacji zapisu pliku, środowisko Deno jest zdecydowanie szybsze od środowiska NodeJS oraz Bun. Wynika to z faktu, że środowisko Deno posiada własną implementacje obiektu pliku, która wykazała w testach, że jest szybsza niż pozostałe środowiska.

W przypadku operacji odczytu pliku środowiska Deno oraz NodeJS są zdecydowanie szybsze od środowiska Bun, wynika to z faktu posiadania wspólnego silnika JavaScript, w którym operacje odczytu pliku są zoptymalizowane. W przypadku środowiska Bun, który bazuje na silniku WebKit, operacje odczytu pliku są wolniejsze, co potwierdziły testy. Zaobserwowano również liniowe zwiększanie pamięci, podczas odczytywania plików ze względu na alokowanie pamięci na dane z danego pliku. Zachowanie to jest zgodne z przewidywaniami, w przypadku operacji odczytu pliku.

W przeciwieństwie do operacji odczytu pliku, operacja zapisu jest zdecydowanie bardziej obciążająca środowiska. Przy każdym z testów zostaje generowane nowe pliki tekstowe, które różnią się zawartością, co wywołuje także trzymanie ich zawartości w pamięci podręcznej. Z tego względu wykonanie takiego testu jest bardziej obciążające dla środowiska, co potwierdzają wyniki testów. Największe zużycie pamięci możemy zobaczyć w przypadku środowiska Bun, które posiada dużo zgłoszonych błędów związanych z pamięcią \cite{bun_memory}. Dodatkowo w przypadku tego środowiska została wykorzystana jego własnej implementacji obiektu pliku. W przypadku środowiska NodeJS oraz Deno zużycie pamięci jest mniejsze, co wynika z optymalizacji operacji zapisu pliku.

Porównując wyniki testów operacji zapisu i odczytu pliku, możemy zauważyć, że operacja zapisu pliku jest bardziej obciążająca dla środowiska niż operacja odczytu pliku. Wynika to z faktu, że operacja zapisu pliku wymaga alokacji pamięci na dane, które mają zostać zapisane, co powoduje zwiększenie zużycia pamięci operacyjnej. W przypadku operacji odczytu pliku, dane są odczytywane z pliku, co nie wymaga alokacji pamięci na dane, co przekłada się na mniejsze zużycie pamięci operacyjnej.

\subsection{Testy obciążeniowe serwera HTTP}
Testy wydajnościowe serwerów HTTP pokazały, że pozyskiwane wartości RPS (ang. \textit{Request per second}) różnią się w zależności od środowiska, w którym zostały stworzone. Program Oha \cite{oha} pozwolił na dokładne zmierzenie tych wartości RPS oraz ich porównanie, wszystkie parametry zostały ustawione tak samo dla każdego środowiska. Wadą programu Oha jest to, że nie pozwala na zmierzenie zużycia pamięci oraz obciążenia procesora, co jest wyznacznikiem obciążenia danego serwera.

Wyniki testów pokazały, że środowisko Deno jest zdecydowanie szybsze od środowiska NodeJs oraz Bun. Posiada on najwyższy wynik wyrażony w RPS, co wynika z faktu, że środowisko Deno bazuje na silniku V8, który jest zoptymalizowany pod kątem wydajności. W przypadku środowiska NodeJS ma ono podobne wyniki do środowiska Deno, co wynika z faktu, że oba środowiska bazują na silniku V8. W przypadku środowiska Bun, które bazuje na silniku WebKit, wyniki są zdecydowanie gorsze od pozostałych środowisk. Wynika to z faktu, że silnik WebKit nie jest zoptymalizowany pod kątem wydajności, co potwierdzają wyniki testów.

Testy wykazały także, że wyniki, które przedstawił twórca Bun w \cite{bun_test} nie potwierdziły się zgodnie z jego przewidywaniami. Twórca środowiska Bun przewidywał, że środowisko Bun będzie zdecydowanie szybsze od środowiska NodeJS oraz Deno. Wyniki testów pokazały, że środowisko Bun jest zdecydowanie wolniejsze od środowiska NodeJS oraz Deno. Pokazuje to fakt, że młode środowisko jakim jest Bun, nie jest jeszcze zoptymalizowane pod kątem wydajności, co potwierdzają wyniki testów.

\subsection{Testy wydajnościowe zapisu i odczytu z bazy danych}
Testy wydajnościowe zapisu i odczytu z bazy danych pokazały, że operacje zapisu i odczytu z bazy danych są zależne od środowiska, w którym są wykonywane. W przypadku operacji zapisu do bazy danych, środowisko Deno jest zdecydowanie szybsze od środowiska NodeJS oraz Bun. Wynika to z faktu, że środowisko Deno posiada własną implementacje obiektu bazy danych, która wykazała w testach, że jest szybsza niż pozostałe środowiska. Dodatkowo środowisko Deno posiada wbudowaną obsługę bazy danych SQLite, co pozwala na szybsze wykonanie operacji zapisu do bazy danych.

W przypadku operacji odczytu z bazy danych środowiska Deno oraz NodeJS są zdecydowanie szybsze od środowiska Bun, wynika to z faktu posiadania wspólnego silnika JavaScript, w którym operacje odczytu z bazy danych są zoptymalizowane. W przypadku środowiska Bun, który bazuje na silniku WebKit, operacje odczytu z bazy danych są wolniejsze, co potwierdziły testy. Zaobserwowano również, że Bun posiada zdecydowanie większe zużycie pamięci operacyjnej, co wynika z licznych błędów związanych z pamięcią \cite{bun_memory}. W przypadku środowiska NodeJS oraz Deno zużycie pamięci jest mniejsze, co wynika z optymalizacji operacji odczytu z bazy danych.

Natomiast w przypadku zapisu do bazy danych, zużycie pamięci jest zdecydowanie większe niż w przypadku odczytu z bazy danych, co jest zgodne z przewidywaniami. W przypadku operacji zapisu do bazy danych, dane są zapisywane do bazy danych, co wymaga alokacji pamięci na dane, co przekłada się na zwiększenie zużycia pamięci operacyjnej. W przypadku operacji odczytu z bazy danych, dane są odczytywane z bazy danych, co nie wymaga alokacji pamięci na dane, co przekłada się na mniejsze zużycie pamięci operacyjnej.

W przypadku zwiększenia ilości rekordów zaobserwowano zwiększenie czasu wykonania operacji zapisu oraz odczytu z bazy danych. Wynika to z faktu, że zwiększenie powoduje zwiększenie ilości danych, które muszą być zapisane lub odczytane z bazy danych, co przekłada się na zwiększenie czasu wykonania operacji. W przypadku zwiększenia ilości rekordów, zużycie pamięci operacyjnej również wzrasta, co jest zgodne z przewidywaniami. Testy zostały przeprowadzone na plikowej bazie danych, co mogło wpłynąć na wyniki testów, w przypadku baz relacyjnych, które mogą być umieszczone na zewnętrznym serwerze, aby odciążyć maszynę, na której wykonywane są testy.
